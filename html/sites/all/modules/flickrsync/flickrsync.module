<?php
// $Id: flickrsync.module,v 1.3 2008/10/31 23:00:51 bjshell Exp $

/**
 * @file
 * Downloads new photos from Flickr and creates Drupal nodes from them.
 */

/**
 * Define response types for flickrsync_node_save().
 */
define('NODE_EXISTS', 0);
define('NODE_CREATED', 1);
define('NODE_UPDATED', 2);

/**
 * Implementation of hook_menu().
 */
function flickrsync_menu() {
  $items['admin/settings/flickrsync'] = array(
    'title' => 'Flickr Sync Settings',
    'description' => 'Configure settings for syncing Flickr images.',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flickrsync_admin_settings')
  );
  $items['flickrsync/import'] = array(
    'title' => 'Import from Flickr',
    'page callback' => 'flickrsync_import',
    'access arguments' => array('import from flickr'),
    'weight' => 1
    //'type' => MENU_DYNAMIC_ITEM
  );
  $items['node/%node/flickrsync'] = array(
    'title' => 'Update from Flickr',
    'page callback' => 'flickrsync_update_node_page',
    'page arguments' => array(1),
    'access arguments' => array('update from flickr'),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function flickrsync_perm() {
  return array('import from flickr', 'update from flickr');
}

/**
 * Implementation of hook_settings().
 */
function flickrsync_admin_settings() {
  $node_types = node_get_types();
  $types[] = '<none>';
  foreach ($node_types as $type => $obj) {
    $types[$type] = $obj->name;
  }
  $form['flickrsync_node_type'] = array(
    '#type' => 'select',
    '#title' => t('Node type to use with Flickr Sync'),
    '#default_value' => variable_get('flickrsync_node_type', ''),
    '#options' => $types,
    '#description' => t('You must select a node type that has an imagefield for the Flickr image download and optionally a free-tagging taxonomy vocabulary.'),
  );
  if ($type = variable_get('flickrsync_node_type', '')) {
    //$fields = content_fields(NULL, $type); // doesn't seem to work as expected
    $info = _content_type_info();
    $fields = $info['content types'][$type]['fields'];

    $choices = array();
    foreach ($fields as $name => $field) {
      if ($field['type'] == 'image') {
        $choices[$name] = $field['widget']['label'];
      }
    }
    if ($choices) {
      $form['flickrsync_image_field'] = array(
        '#type' => 'select',
        '#title' => t('Image field for attaching Flickr photo'),
        '#default_value' => variable_get('flickrsync_image_field', ''),
        '#options' => $choices,
        '#description' => t('Select the image field to use for attaching Flickr images to Drupal nodes.'),
      );
    }
    else {
      drupal_set_message("The node type selected doesn't have any image fields.  Please select a different node type, or add an image field to this node type.", 'error');
    }

    $vocabs = taxonomy_get_vocabularies($type);
    $choices = array();
    foreach ($vocabs as $vocab) {
      // is free tagging enabled?
      if ($vocab->tags == 1) {
        $choices[$vocab->vid] = $vocab->name;
      }
    }
    if ($choices) {
      $form['flickrsync_vocab'] = array(
        '#type' => 'select',
        '#title' => t('Vocabulary for importing Flickr tags'),
        '#default_value' => variable_get('flickrsync_vocab', ''),
        '#options' => $choices,
        '#description' => t('Select a free-tagging vocabulary to use for importing Flickr tags.'),
      );
    }
    else {
      drupal_set_message("The node type selected doesn't have a free tagging vocabulary.
        This is optional, but you want want to consider configuring a vocabulary so that Flickr tags
        can be imported.");
    }
  }
  $form['flickrsync_timeout'] = array(
    '#type' => 'textfield',
    '#title' => t('Timeout when importing Flickr images'),
    '#default_value' => variable_get('flickrsync_timeout', 30),
    '#description' => t('The number of seconds to allow for an individual image import to complete.'),
  );
  $form['flickrsync_cron_number'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of Flickr images to import during each cron run'),
    '#default_value' => variable_get('flickrsync_cron_number', 10),
    '#description' => t('Use a low number to avoid PHP timing out during cron, especially if other intensive cron tasks are also running.  Keep in mind that you may need to run cron frequently if lots of Flickr photos need to be imported.'),
  );
  return system_settings_form($form);
}

/**
 * Implementation of hook_user().
 * Adds extra fields for the user to enter a Flickr identifier and specify
 * other Flickr Sync options.
 */
function flickrsync_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'form':
      if ($category == 'account') {
        $user = user_load(array('uid' => $account->uid));
        $form['flickrsync'] = array(
          '#type' => 'fieldset',
          '#title' => t('Flickr sync settings'),
          '#collapsible' => FALSE,
          '#weight' => 4,
          '#tree' => FALSE,
        );
        $form['flickrsync']['flickrsync_identifier'] = array(
          '#type' => 'textfield',
          '#title' => t('Flickr identifier'),
          '#default_value' => $user->flickrsync['identifier'],
          '#description' => t('Enter either your Flickr username, the email address associated with your Flickr account, or your Flickr NSID. Leave this box empty to stop syncing your Flickr images with this site.'),
          '#maxlength' => 64,
        );
        $form['flickrsync']['flickrsync_start_date'] = array(
          '#type' => 'textfield',
          '#title' => t('Date of first Flickr photo to import'),
          '#default_value' => ($start_date = $user->flickrsync['start_date']) ? date('c', $start_date) : '',
          '#description' => t('Enter the posted date (in any standard date format) of the first Flickr image you want to import.  Leave blank to import all your Flickr images.'),
        );
        $form['flickrsync']['flickrsync_tags'] = array(
          '#type' => 'textfield',
          '#title' => t('Flickr tags to import'),
          '#default_value' => $user->flickrsync['tags'],
          '#description' => t('Enter a comma separated list of tags to use for selecting Flickr images to import.  Leave blank to import all your Flickr images.'),
        );
        return $form;
      }
      break;
    case 'validate':
      if (!empty($edit['flickrsync_identifier'])) {
        if (!flickrapi_get_user_nsid($edit['flickrsync_identifier'])) {
          form_set_error('flickrsync_identifier', t('%ident is not a valid Flickr username, email, or NSID.', array('%ident' => $edit['flickrsync_identifier'])));
        }
      }
      break;
    case 'insert':
    case 'update':
      if (isset($edit['flickrsync_identifier'])) {
        db_query('DELETE FROM {flickrsync_users} WHERE uid=%d', $account->uid);
        $user_affected = db_affected_rows();
        if (!empty($edit['flickrsync_identifier'])) {
          db_query("INSERT INTO {flickrsync_users} (uid, nsid, identifier, start_date, tags) VALUES (%d, '%s', '%s', %d, '%s')",
                    $account->uid,
                    flickrapi_get_user_nsid($edit['flickrsync_identifier']),
                    $edit['flickrsync_identifier'],
                    strtotime($edit['flickrsync_start_date']),
                    $edit['flickrsync_tags']);
        }
        else if ($user_affected) {
          //flickr account removed
          drupal_set_message(t("%username's Flickr syncing has been disabled.", array('%username' => $account->name)));
        }
      }
      $edit['flickrsync_identifier'] = NULL;
      break;
    case 'load':
      $result = db_query('SELECT * FROM {flickrsync_users} WHERE uid=%d', $account->uid);
      if ($flickr_info = db_fetch_object($result)) {
        $account->flickrsync['identifier'] = $flickr_info->identifier;
        $account->flickrsync['nsid'] = $flickr_info->nsid;
        $account->flickrsync['start_date'] = $flickr_info->start_date;
        $account->flickrsync['tags'] = $flickr_info->tags;
      }
      break;
    case 'delete':
      db_query('DELETE FROM {flickrsync_users} WHERE uid=%d', $account->uid);
      break;
  }
}

/**
 * Implementation of hook_cron().
 */
function flickrsync_cron() {
  flickrsync_update_feeds();
}

/**
 * This will check for new images for all users.
 */
function flickrsync_update_feeds() {
  $limit = variable_get('flickrsync_cron_number', 10);
  $total = 0;
  $photos = array();

  // build an array of photos to import
  $result = db_query("SELECT * from {flickrsync_users} ORDER BY start_date ASC");
  while (($fuser = db_fetch_object($result)) && ($total < $limit)) {

    // load the user
    $user = user_load(array('uid' => $fuser->uid));
    $feed = flickrsync_get_new_photos_feed($user, $limit - $total);

    if (is_array($feed['photos'])) {
      $photos = array_merge($photos, $feed['photos']);
      $total += $feed['count'];
    }
  }

  // import the photos
  if (is_array($photos)) {
    foreach ($photos as $photo) {
      flickrsync_create_node($photo['id']);
    }
  }

  return 'Flickr Import complete';
}

function flickrsync_update_node_page($node) {
  $nid = $node->nid;
  $photo_id = flickrsync_get_photo_id($nid);
  flickrsync_update_node($photo_id, TRUE);
  return '';
}

/**
 * Import page, which calls the update process from JavaScript (to improve page responsiveness)
 */
function flickrsync_import() {
  $op = isset($_REQUEST['op']) ? $_REQUEST['op'] : '';

  switch ($op) {
    case 'finished':
      return flickrsync_import_finished_page(TRUE);
      break;

    case 'error':
      return flickrsync_import_finished_page(FALSE);
      break;

    case 'do_import_js':
      print flickrsync_import_do_import_js();
      break;

    case 'do_import_nojs':
      return flickrsync_import_progress_page_nojs();
      break;

    default:
      return flickrsync_import_start_page();
      break;
  }
}

function flickrsync_init_header() {
  $path = drupal_get_path('module', 'flickrsync');

  // add CSS
  drupal_add_css($path .'/flickrsync.css');

  // JavaScript
  drupal_add_js('misc/progress.js', 'core', 'header', FALSE, TRUE);
  drupal_add_js($path .'/flickrsync.js', 'module', 'header', FALSE, FALSE);
  drupal_add_js(
    array(
      'flickrsync' => array(
        'url' => array(
          'finished' => url('flickrsync/import', array('query' => 'op=finished')),
          'do_import' => url('flickrsync/import', array('query' => 'op=do_import_js'))
        )
      )
    ), 'setting'
  );
}

function flickrsync_import_start_page() {
  global $user;
  $fuser = user_load(array('uid' => $user->uid));

  // verify that the user has a Flickr username identifier
  if (!$fuser->flickrsync['nsid']) {
    drupal_set_message(t("Unable to find your Flickr username!
                          Please configure it in your !account-settings.",
                          array('!account-settings' =>
                          l('account settings', 'user/'. $fuser->uid .'/edit'))),
                          'error');
    return '';
  }

  // add JS and CSS
  flickrsync_init_header();

  // get user's start date
  $posted_after = '';
  if ($fuser->flickrsync['start_date']) {
    $posted_after = 'posted on or after '. date('m/d/y', $fuser->flickrsync['start_date']);
  }

  // get user's tags
  if ($fuser->flickrsync['tags']) {
    $tags = explode(',', $fuser->flickrsync['tags']);
    $formatted_tags = array();
    foreach ($tags as $tag) {
      $formatted_tags[] = '<span class="tag">'. trim($tag) .'</span>';
    }
    $tags = implode(', ', $formatted_tags);
  }

  // build formatted string
  if ($tags) {
    $text = t('Only images !posted-after-date with these tags will be imported: !tags',
              array('!posted-after-date' => $posted_after, '!tags' => $tags));
  }
  elseif ($posted_after) {
    $text = t('Only images !posted-after-date will be imported.',
              array('!posted-after-date' => $posted_after));
  }
  else {
    $text = t('All your Flickr images will be imported. !edit-your-account to limit the import to specific
              image tags or to limit the import to only recent images.',
              array('!edit-your-account' => l('Edit your account', 'user/'. $user->uid .'/edit')));
  }

  $output[] = '<div id="flickrsync-import">';
  $output[] = '  <div class="notes">'. $text .'</div>';

  if ($_POST['op']) {
    $_SESSION['flickrsync_init'] = 1;
    if ($_POST['has_js']) {
      $output[] = flickrsync_import_progress_page_js();
    }
    else {
      drupal_goto('flickrsync/import', 'op=do_import_nojs');
    }
  }
  else {
    $output[] = drupal_get_form('flickrsync_import_start_form');
  }

  $output[] = '</div>';
  return implode("\n", $output);
}

function flickrsync_import_start_form() {
  $form = array();
  $form['has_js'] = array(
    '#type' => 'hidden',
    '#default_value' => FALSE,
    '#attributes' => array('id' => 'edit-has_js'),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Import',
  );
  return $form;
}

function flickrsync_import_progress_page_js() {
  $output = array();
  $output[] = '<div id="progress"></div>';
  $msg = t('Importing your images may take awhile.  You can stop the import at anytime and resume later.');
  $output[] = '<p id="flickrsync-stop-msg">'. $msg .'</p>';
  $output[] = '<div id="flickrsync-btns">';
  $output[] = '  <input id="flickrsync-stop" type="button" value="Stop" />';
  $output[] = '</div>';
  return implode("\n", $output);
}

function flickrsync_import_progress_page_nojs() {
  // add JS and CSS
  flickrsync_init_header();

  $new_op = 'do_import_nojs';
  if ($_SERVER['REQUEST_METHOD'] == 'GET') {
    // Error handling: if PHP dies, it will output whatever is in the output
    // buffer, followed by the error message.
    ob_start();
    print '<p class="error">An unrecoverable error has occurred. You can find the error message below.</p>';

    list($percentage, $message) = flickrsync_import_do_import();
    if ($percentage == 100) {
      $new_op = 'finished';
    }

    // import successful; remove fallback
    ob_end_clean();
  }
  else {
    // This is the first page so return some output immediately.
    $percentage = 0;
    $message = 'Starting updates';
  }

  drupal_set_html_head('<meta http-equiv="Refresh" content="0; URL='. url('flickrsync/import', 'op='. $new_op) .'">');
  $output  = '<div id="flickrsync-import">';
  $output .= theme('progress_bar', $percentage, $message);
  $msg = t('Importing your images may take awhile.  You can !stop-the-import at anytime and resume later.',
            array('!stop-the-import' => l('stop the import', 'flickrsync/import')));
  $output .= '<p id="flickrsync-stop-msg">'. $msg .'</p>';
  $output .= '</div>';

  return $output;
}

function flickrsync_import_do_import_js() {
  // Error handling: if PHP dies, the output will fail to parse as JSON, and
  // the Javascript will tell the user to continue to the op=error page.
  list($percentage, $message) = flickrsync_import_do_import();
  print drupal_to_js(array('status' => TRUE, 'percentage' => $percentage, 'message' => $message));
}

/**
 * Perform updates for one second or until finished.
 *
 * @return
 *   An array indicating the status after doing updates. The first element is
 *   the overall percentage finished. The second element is a status message.
 */
function flickrsync_import_do_import() {
  // intialization step one: just display a loading message
  if ($_SESSION['flickrsync_init'] == 1) {
    $_SESSION['flickrsync_init'] = 2;
    return array(0, 'Loading list of images to import');

  // intialization step one: load the user's Flickr feed
  }
  elseif ($_SESSION['flickrsync_init'] == 2) {
    $_SESSION['flickrsync_init'] = 0;

    global $user;
    $fuser = user_load(array('uid' => $user->uid));

    // get a list of the new photos for the current user
    $feed = flickrsync_get_new_photos_feed($fuser);

    // reset session variables, used by the AJAX callback
    $_SESSION['flickrsync_remaining'] = $feed['photos'];
    $_SESSION['flickrsync_total'] = $feed['count'];
    $_SESSION['flickrsync_current'] = 0;
    $_SESSION['flickrsync_timer'] = time();
    $_SESSION['flickrsync_start'] = FALSE;

    return array(0, 'Starting import');
  }

  // start actual import
  while (isset($_SESSION['flickrsync_remaining']) && ($update = reset($_SESSION['flickrsync_remaining']))) {
    if ($_SESSION['flickrsync_current'] != $update['id']) {
      $_SESSION['flickrsync_current'] = $update['id'];
      $_SESSION['flickrsync_timer'] = time();

      $result = flickrsync_create_node($update['id']);
      if ($result['success'] == TRUE) {
        // Dequeue the completed update.
        unset($_SESSION['flickrsync_remaining'][key($_SESSION['flickrsync_remaining'])]);
      }
    }

    if (timer_read('page') > 1000) {
      break;
    }
  }

  // timeout if one photo takes too long
  if (($_SESSION['flickrsync_timer'] + variable_get('flickrsync_timeout', 30)) < time()) {
    drupal_set_message('Timeout: Unable to import from Flickr', 'error');
    return array(100, 'Timeout: Unable to import from Flickr');
  }

  if ($_SESSION['flickrsync_total']) {
    $percentage = floor(($_SESSION['flickrsync_total'] - count($_SESSION['flickrsync_remaining']) + $update_finished) / $_SESSION['flickrsync_total'] * 100);
  }
  else {
    $percentage = 100;
  }

  return array($percentage, isset($update['title']) ? 'Importing image: '. $update['title'] : 'Flickr sync complete');
}

function flickrsync_import_finished_page() {
  $output = array();
  $output[] = '<div id="flickrsync-update">';
  $output[] = '  <div>The import from your Flickr photostream is complete!</div>';
  $output[] = '</div>';
  return implode("\n", $output);
}

function flickrsync_get_new_photos_feed($user, $limit = 0) {
  // initialize phpFlickr object
  $f = flickrapi_phpFlickr();
  if (!$f) {
    drupal_set_message(t("Unable to access Flickr API"), 'error');
    return FALSE;
  }

  // verify that the user has a Flickr username identifier
  if (!$user->flickrsync['nsid']) {
    drupal_set_message(t("Unable to find Flickr username for %user", array('%user' => $user->name)), 'error');
    return FALSE;
  }

  // get the user's starting timestamp and tags
  $start_date = 0;
  $tags = '';
  $result = db_query("SELECT start_date, tags FROM {flickrsync_users} WHERE uid=%d", $user->uid);
  if ($data = db_fetch_array($result)) {
    $start_date = $data['start_date'];
    $tags = $data['tags'];
  }

  // do Flickr API search for photos
  $photos = array();
  $current_page = 0;
  $total_num_pages = 1; // at least 1 page
  $per_page = ($limit && $limit < 500) ? $limit : 500;
  while ($total_num_pages > $current_page) {
    $current_page++;
    $data = $f->photos_search(array(
      'user_id' => $user->flickrsync['nsid'],
      'per_page' => $per_page,
      'page' =>  $current_page,
      'sort' => 'date-posted-asc',
      'min_upload_date' => $start_date,
      'tags' => $tags
    ));
    $total_num_photos = $data['total'];
    if ($limit) {
      $total_num_pages = ceil($limit / 500);
    }
    else {
      $total_num_pages = $data['pages'];
    }
    if (is_array($data['photo'])) {
      $photos = array_merge($photos, $data['photo']);
    }
  }

  return array(
    'count' => count($photos), //$total_num_photos,
    'photos' => $photos
  );
}

/**
 * Helper function, to get drupal user details for a flickr user
 */
function flickrsync_get_user_by_flickruser($fuser) {
  if (!$fuser) {
    drupal_set_message(t("Cannot search for blank username"));
    return;
  }
  $flickruser = db_fetch_object(db_query("SELECT * FROM {flickrsync_users} WHERE nsid='%s' OR identifier='%s'", $fuser, $fuser));
  if (!$flickruser) {
    drupal_set_message(t("Flickruser %flickrusername is not a registered user of this site", array('%flickrusername' => $fuser)));
    return;
  }

  $user = user_load(array('uid' => $flickruser->uid));
  return $user;
}

/**
 * Makes a node for a flickr photo
 */
function flickrsync_create_node($photo_id) {
  $data = flickrsync_node_save($photo_id);
  switch ($data['status']) {
    case NODE_EXISTS:
    case NODE_CREATED:
      $nid = $data['nid'];
      //drupal_set_message('process this');
      $result = db_query("SELECT fp.upload_date, n.uid
                          FROM {flickrsync_photos} fp
                          INNER JOIN {node} n ON n.nid=fp.nid
                          WHERE fp.nid=%d", $nid);
      $values = db_fetch_array($result);

      // update start_date in user's settings
      db_query("UPDATE {flickrsync_users} SET start_date=%d WHERE uid=%d", $values['upload_date'], $values['uid']);
      break;
  }
  return $data;
}

/**
 * Updates a flickr photo node
 */
function flickrsync_update_node($photo_id) {
  flickrsync_node_save($photo_id, TRUE);
}

/**
 * Saves a flickr photo node (new or existing).
 */
function flickrsync_node_save($photo_id, $update_nodes = FALSE) {
  if (!$photo_id) {
    drupal_set_message(t("Photo ID required"));
    return FALSE;
  }

  if ($nid = flickrsync_get_nid($photo_id)) {
    if ($update_nodes !== TRUE) {
      return array(
        'success' => TRUE,
        'status' => NODE_EXISTS,
        'nid' => $nid
      );
    }
    $node = node_load($nid);
  }
  else {
    $node = new stdClass();
  }

  $f = flickrapi_phpFlickr();
  if (!$f) {
    drupal_set_message(t("Unable to access Flickr API"), 'error');
    return FALSE;
  }

  // info to put into the node
  $flickr_photo = $f->photos_getInfo($photo_id);

  // flickr username
  $flickrusername = $flickr_photo['owner']['username'];

  // get user details
  $user = flickrsync_get_user_by_flickruser($flickrusername);
  if (!$user) {
    drupal_set_message(t("User doesn't exist, unable to save image %photo_id", array('%photo_id' => $photo_id)));
    return FALSE;
  }

  // get the path to the largest available image size (cached locally)
  $file = flickrsync_download_photo($flickr_photo, 'largest');

  $content = '';
  if ($flickr_photo['description']) {
    $content .= '<p>'. htmlentities(html_entity_decode($flickr_photo['description'])) .'</p>';
  }

  // image field
  $imagefield = variable_get('flickrsync_image_field', '');
  if ($imagefield) {
    $file['list'] = 1;
    $file['data']['description'] = '';
    $file['status'] = 1;
    unset($file['source']);
    unset($file['destination']);
    $node->{$imagefield} = array($file);
  }
  else {
    drupal_set_message(t("Image field not configured in Flickr sync settings"), 'error');
  }

  // tags
  $flickr_tags = $flickr_photo['tags']['tag'];
  $tags = array();
  $vid = variable_get('flickrsync_vocab', '');
  if ($vid) {
    foreach ($flickr_tags as $tag) {
      $tags[] = $tag['raw'];
    }
    $node->taxonomy = array(
      'tags' => array(
          $vid => implode(',', $tags)
        )
    );
  }

  $node->title = htmlentities($flickr_photo['title']);
  $node->created = strtotime($flickr_photo['dates']['taken']);
  $node->teaser = $content;
  $node->format = 3;
  $node->body = $content;
  $node->name = $user->name;
  $node->uid = $user->uid;
  $node->type = variable_get('flickrsync_node_type', '');
  $node->published = 1;
  $node->status = 1;
  node_save($node);

  if ($node->is_new) {
    $result = db_query("INSERT INTO {flickrsync_photos} (flickrphoto_id, nid, upload_date, taken_date)
                        VALUES (%s, %d, %d, %d)",
                        $photo_id, $node->nid, $flickr_photo['dates']['posted'], strtotime($flickr_photo['dates']['taken']));
    drupal_set_message(t("New image created, !title", array('!title' =>  l($flickr_photo['title'], 'node/'. $node->nid))));
  }
  else {
    drupal_set_message(t("Updated image %photo_id, ". l($node->title, 'node/'. $node->nid), array('%photo_id' => $photo_id)));
  }

  return array(
    'success' => TRUE,
    'status' => ($node->is_new) ? NODE_CREATED : NODE_UPDATED,
    'nid' => $node->nid,
    'node' => $node
  );
}

/**
 * Work out the path to a photo - also handles the cache on the local filesystem
 */
function flickrsync_download_photo($flickr_photo, $size = FALSE) {
  if ($size == 'largest') {
    // get largest size
    $f = flickrapi_phpFlickr();
    $sizes = $f->photos_getSizes($flickr_photo['id']);
    $size = $sizes[count($sizes) - 1]; // largest available size
    $src = $size['source'];

    // set the $size variable to a size letter for naming the file if it's cached
    preg_match('/_([a-z])\./', $src, $match);
    if (!($size = $match[1])) {
      $size = '';
    }
  }
  else {
    // ref: http://farm{farm-id}.static.flickr.com/{server-id}/{id}_{secret}.jpg
    $sz = ($size) ? '_'. $size : '';
    $src = "http://farm{$flickr_photo['farm']}.static.flickr.com/{$flickr_photo['server']}/{$flickr_photo['id']}_{$flickr_photo['secret']}{$sz}.jpg";
  }

  $folder = file_create_path('flickrtemp');
  if (!file_check_directory($folder) && !mkdir($folder, 0775, TRUE)) {
    watchdog('flickrsync', 'Failed to create Flickr sync temp directory: %dir', array('%dir' => $folder), WATCHDOG_ERROR);
    drupal_set_message(t('Failed to create Flickr sync temp directory'), 'error');
    return FALSE;
  }

  $filename =  "{$folder}/{$flickr_photo['id']}_{$flickr_photo['secret']}{$sz}.jpg";

  // download image file from Flickr
  require_once "HTTP/Request.php";
  $req =& new HTTP_Request($src);
  // Something went wrong?
  if (PEAR::isError($req->sendRequest())) {
    $msg = t("Failed to retrieve jpeg file from Flickr.com, url = %url", array('%url' => $src));
    drupal_set_message($msg);
    watchdog('flickrsync', $msg, NULL);
    return FALSE;
  }

  // save the JPEG image data into a temporary file
  $contents = $req->getResponseBody();
  if (file_save_data($contents, $filename, FILE_EXISTS_REPLACE)) {

    // Prepare to copy the file to it's permanent location by first deleting any file in it's place.
    // Ordinarily this could be dangerous, but because of the uniquness of the Flickr filenames
    // it shouldn't be a problem.  Without this step, if this function is called twice for a photo
    // the second photo will get _0 appended to the end AND it will produce an error.
    $directory = file_create_path();
    file_delete($directory .'/'. basename($filename));

    // Move the temp file to it's permanent location and save an entry in the files table.
    if ($file = field_file_save_file($filename, array(), $directory, TRUE)) {

      // Delete the temp file.
      file_delete($filename);

      // Return the Drupal $file object.
      return $file;
    }
    else {
      watchdog('flickrsync', 'Failed to copy temp file into files table and permanent location: %filename', array('%filename' => $filename));
    }
  }
  else {
    watchdog('flickrsync', 'Failed to save temp file of Flickr image: %filename', array('%filename' => $filename));
  }
  drupal_set_message(t("Failed to save Flickr image"));
  return FALSE;
}

/**
 * Implementation of hook_nodeapi().
 */
function flickrsync_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'load':
      //print_r($node);
      break;
    case 'delete':
      db_query('DELETE FROM {flickrsync_photos} WHERE nid = %d', $node->nid);
      break;
  }
}

/**
 * Get the node ID for a flickr photo ID
 */
function flickrsync_get_nid($photo_id) {
  $result = db_query("SELECT nid FROM {flickrsync_photos} WHERE flickrphoto_id='%s'", $photo_id);
  if ($photo_rec = db_fetch_object($result)) {
    return $photo_rec->nid;
  }
}

/**
 * Get the Flickr photo ID for a node ID
 */
function flickrsync_get_photo_id($nid) {
  $record = db_fetch_object(db_query("SELECT flickrphoto_id from {flickrsync_photos} where nid=%d", $nid));
  return $record->flickrphoto_id;
}
